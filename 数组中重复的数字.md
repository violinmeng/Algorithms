### 找出数组中重复的数字。  
#### 在一个长度为n的数组里的所有数字都在0~n-1的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字，
  
    例如：长度为7的数组{2，3，1，0，2，5，3}，那么对应的输出是数字2或者3.

通常的做法是，先排序，然后很容易就找出重复的数字，排序算法最优的时间复杂的是O(nlogn)。  
还有可以用散列表存储，已经遍历的数字，很容易寻找到重复的数字。这个算法时间复杂度是O(n),但是空间复杂度也是O(n)。  

那么有没有时间复杂度为O(n),空间复杂度为O(1)的算法呢？  

我们看下题目有几个关键点，数字是限定在一定范围内的，找出的是任意一个重复的数字。  

我们知道数组可以看作一个简单的散列表。那么我们可以将数组的下标和数组的值，对应起来；通过交换位置，把值为m的数字，放到下标为m的位置；  
在找到重复值之前的位置，可以看成是一个，下标=value的散列表。如果m的值小于当前的下标，那么m是重复的值；  
如何保证m之前的数字是下标=value的呢。首先下标0的值和值对应的下表进行交换。直到下表0的位置为0（交换之前检查是否相等，如果是就可以直接返回了），进行下标为1的位置检查。

### 扩展
那么如果数值范围是k~n+k-1范围的数字呢？同样的思路，只是和下表对应有一个偏移量；  

那么如和输出所有的重复的数，以及重复的次数呢？采用这种方法可以么？  
我们在发现在下标k出重复的数m时候，输出重复的数m，  
同时将下标m处的数设置为一个标志比如 ***$*** ,标识这个数字已经重复了，如果有第三个m时，只需要加重复次数就可以了。  
而把k处的值设置为标志位 ***#*** ，标识这个数字已经处理输出了重复的数了。如果 ***#*** 交换到了新的位置，下次在处理它的时候，直接忽略，处理下一位；  

### 不修改数组找出重复的数字
#### 在一个长度为n+1的数组里的所欲数字，都在1~n的范围内，所以数组中至少有一个数字是重复的。找出数组中任意一个重复的数字，但不饿能修改输入的数组。

可以很容易想到用一个O(n)的辅助数组，用O(n)的时间找出重复的数。

那么不用额外的空间找到重复的数字么？

可以利用二分法，我们将1\~n范围二分，在1\~(m+1)/2范围内,如果有(n+1)/2 +1个数在这个范围，那么这个范围内肯定存在重复的数，反之在另一半区间内，以此类推，最后就可以得到一个重复的数。  
边界条件就是区间为0，在这个区间的数字，大于1。  
这种方式的时间复杂度为O(nlogn),空间复杂度为O(1);这是一种相比于辅助数组，以时间换空间的算法。  

