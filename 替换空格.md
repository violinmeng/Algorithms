### 请实现一个函数，把字符串中的每个空格替换成“%20”

    例如，输入"We are happy.",输出"we%20are%20%happy."
    
这个问题有一个点需要注意：这个替换是在原有的字符串上替换。  
如果不在原有字符串上替换，我们可以从前到后遍历字符串，遇到空格就可以替换为对应字符。这个时间复杂度是O(n),空间复杂度也是O(n).  

如果是在原有的字符串上进行替换呢。  
很自然的一个思路是，遍历字符串，当遇到空格替换对应字符，然后把空格后的字符，都后移三个字符。再便利之后的字符，直到遇到下一个空格，执行相同的操作，依次类推。
这种方案，再移动空格之后字符串的操作会很耗时，这个方案的时间复杂度是O(n<sup>2</sup>);  

那么有更优的解么？  
如果我们知道字符串中有几个空格（我们可以遍历一次字符串很容易得到），设为m，那么我们就可以知道最后一个空格字符移动的位数为3\*m，倒数第二个空字符，到倒数第一个
空字符之间的字符，移动的位数是3\*m-3位，一次类推我们就可以实现替换，并且每个字符只需要移动一次。这个算法的时间复杂度为O(n)。  

当一个字符串数组按照顺序处理有些复杂的时候，可能从反向处理会更加的清晰。  

例如有两个排序的数组A1和A2，内存在A1的末尾有足够多的空余空间容纳A2，请事先一个函数，把A2的所欲数字插入A1，并且所有数字是排序的。  
同样的道理如果我们从前往后插入A2的数字的话，那么需要频繁移动插入点之后的数组A1的元素。  
因为A1和A2长度已知，合并之后的长度也是已知。  
因此从最后的数字开始插入，就避免了频繁移动A1的元素了。  
